require_relative "./ScenarioManager.rb"
require_relative './Timer.rb'

class Simulator
    attr_accessor :icm, :inputParams, :scenarioInfo, :timer

    def initialize(icm, inputParams)
        @icm = icm
        @inputParams = inputParams
        @scenarioInfo = {}
        @timer = Timer.instance
    end

    # read the params from the file created by the UI and sets up the simulation object, then runs and exports the simulations
    def setupAndRunSimulations()
        setupBase()
        scenarioManager = ScenarioManager.new(@icm, @inputParams)
        scenarioManager.setupScenarios()
        params = setupSimulation(scenarioManager.scenarios.keys)
        @timer.addBreakpoint("Scenariosetup")
        basepath = setupResultDir(params['runname'])
        puts "Scenarios have been set up: commencing simulations"
        if @inputParams['ExecuteRun'] == true
            runSimulations(params['sims'])
            exportSimulations(params['sims'], params['runname'], scenarioManager.scenarios, basepath)
            cleanupScenarios(scenarioManager.scenarios)
        end
        @timer.finish()
        exportRunSummary(params['sims'], params['runname'])
    end

    def setupResultDir(runname)
        currpath = Dir.pwd
        basepath = "#{currpath}\/results\/#{runname}"
        begin
            Dir.mkdir basepath
        rescue Exception => e
        end
        File.open("#{basepath}/inputParams.json", "w"){|f| f.write(@inputParams.to_json())}
        return basepath
    end
    
    # delete all scenarios that are in [scenarios]
    def cleanupScenarios(scenarios)
        @icm.openNetwork.current_scenario = "Base"
        scenarios.each do |scene| 
            @icm.openNetwork.delete_scenario(scene)
            $logger.info("deleted scenario: #{scene}")
        end
        @timer.addBreakpoint("cleanup") 
    end
    
    def setupBase()
        basename = @inputParams['RunName']
        scenarioname = self.chooseScenarioName(basename) #helps with picking a unique base scenario name
        scenariotest = @icm.openNetwork.add_scenario(scenarioname, "Base", "Scenario generated by DGInfoworks")  
        @icm.openNetwork.current_scenario = scenarioname
        $logger.info("Scenario #{scenarioname} created")
    end

    def setupSimulation(scenarios)
        validations = @icm.openNetwork.validate(scenarios)
        if validations.error_count > 0
            validationErrorHandling(validations)
            raise Exception.new("could not validate, you have probably supplied an impossible/illegal value, please check in infoworks icm what is wrong with the scenario")
        end
        @icm.net.commit("committing #{icm.openNetwork.current_scenario} changes")
        base = @icm.db.model_object_from_type_and_id( @icm.net.parent_type(), @icm.net.parent_id())
        baseint =0 
        baserunname = @inputParams['RunName']
        runname = baserunname
        while true 
            begin  
                extraParameters = @inputParams['simparameters']
                rainfallevents = @inputParams['rainfallevents']
                run = base.new_run(runname, @icm.net, nil, rainfallevents, scenarios, extraParameters) #run=mo.new_run(name,network,commit_id,rainfalls_and_flow_surveys,scenarios,parameters)
                break
            rescue Exception => e
                if e.message != "new_run : name already in use"
                    $logger.fatal(e.message)
                    raise(e)
                else 
                    $logger.info( "name: #{runname} already in use, trying new name")
                    runname = "#{baserunname}#{baseint}"
                    baseint = baseint+1
                end
            end
        end
        $logger.info("run #{runname} created")
        mocsims = run.children # sims as a modelobjectcollection object
        sims = []
        mocsims.each { |x| sims << x }
        params = {"sims" => sims, "runname" =>runname}
        return params
    end

    def runSimulations(sims)
        WSApplication.connect_local_agent(1)
        jobids = WSApplication.launch_sims(sims, '.', false, 1, 0)
        WSApplication.wait_for_jobs(jobids, true, 100000000)
        @timer.addBreakpoint("Simulations finished")
        puts "Simulations finished"
    end

    def exportSimulations(sims, runname, scenariosObject, basepath)
        puts "Exporting to #{basepath}"
        @timer.addBreakpoint("Export setup done")
        sims.each_with_index do | sim, index | 
            path = "#{basepath}/#{sim.name}"
            resultpath = "#{path}/sim_results"
            begin
                Dir.mkdir path
                Dir.mkdir "#{path}/current_network"
                Dir.mkdir resultpath
            rescue Exception => e
                $logger.error(e.message)
                raise(e)
            end
            scenarioFoundFlag = false
            scenarioName = ""
            scenariosObject.keys.each do |scene| 
                if sim.name.include?("#{scene} ")
                    @icm.openNetwork.current_scenario = scene
                    scenarioFoundFlag = true
                    break
                end
            end
            if !scenarioFoundFlag
                raise Exception.new("scenario not found")
            end
            relativepath = "results/#{runname}/#{sim.name}"
            @icm.openNetwork.csv_export("#{relativepath}/current_network/#{icm.openNetwork.current_scenario}", {'Multiple Files' => true}) # this argument takes relative file position
            $logger.info("exporting to: #{path}")
            File.open("#{relativepath}/changes.json", "w"){|f| f.write(scenariosObject[@icm.openNetwork.current_scenario].to_json())}
            sim.results_csv_export(nil,  resultpath)
            @timer.addBreakpoint(sim.name)
        end 
        cleanupScenarios(scenariosObject.keys)
        @icm.net.commit("deleted scenarios from #{runname}")
    end

    def exportRunSummary(sims, runname)
        runSummary = @timer.export()
        runSummary['total Simulations'] = sims.length
        runSummary['total Timestep per simulation'] = (@inputParams['simparameters']['Duration']*60) / @inputParams['simparameters']['TimeStep']
        runSummary['total fields changed'] = @inputParams['FieldsChanged']
        File.open("results/#{runname}/summaryInfo.json", "w"){ |f|
            f.write(runSummary.to_json())
        } 
    end

    #function for picking a unique base name for the scenario to avoid duplicate scenario bugs
    def chooseScenarioName(basename)
        allScenarios = []
        @icm.openNetwork.scenarios do |s|
            allScenarios << s
        end
        workname = basename
        baseint = 0
        lambda_inScenario = lambda {|name, scenarios|
            scenarios.each do | s |
                if(s.include?(name))
                    return true
                end
            end
            return false
            }
        while lambda_inScenario.call(workname, allScenarios)
            workname = "#{basename}#{baseint}"
            baseint = baseint+1
        end
        return workname
    end 

    def validationErrorHandling(validations)
        validations.each{ |validation|
            if validation.type == "error"
                @logger.error(validation.object_message)
            end
        }
    end
end